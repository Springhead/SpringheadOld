% 2.3.3.Problems.tex
%	Last update: 2020/02/13 F.Kanehori
%newpage
\subsubsection{問題点}
\label{subsubsec:Problems}
\parindent=0pt

\def\App#1{\it{App#1\,}}
\def\App#1{\it{App#1\,}}

前節\KQuote{\ref{subsubsec:CmakeMethod}CMakeを使用した場合} に示したような
アプリケーション\App{1}の他にアプリケーション\App{2}があったとして、
その両方を同時に開いて作業を行なう場合を考えます。
ここでは\App{1}と\App{2}が共通して参照する\SprLib のプロジェクトについてのみ考えます。

\bigskip
\bf{ソースファイルの整合性}
\begin{narrow}[20pt]
	ソースファイルの整合性には問題がありません。
	\App{1}と\App{2}のどちらも\SprLib のソースツリーを指すようにしてありますから、
	どちらで実施したソースファイルの変更も直ちに他方に反映されることになります。
	(同じファイルを参照しているのですから当然です)

	\medskip
	ソースファイルの追加や削除を実施したとしても
	ソースファイルの整合性自体が崩れるわけではありません。
	ただし、この場合には\KQuote{\bf{プロジェクトファイルの整合性}}(後述)
	の問題が発生します。
\end{narrow}

\medskip
\bf{ビルドの最適性(無駄なコンパイル)}
\begin{narrow}[20pt]
	\App{1}と\App{2}のビルドツリーは異なるものですから、
	\App{1}でソースを変更してビルドしたとしても
	そのビルド結果(オブジェクトファイル)がそのまま\App{2}から見える訳ではありません。

	\medskip
	\App{2}でこの変更を反映させようとすれば\App{2}での再ビルドが必要ですが、
	再ビルドを行なった時点で初めて変更されたソースファイルが再コンパイルされ、
	オブジェクトファイルの整合性がとれることになります。
	従来はオブジェクトファイルも共有されていましたから、
	このような無駄なコンパイルは発生しませんでした。
\end{narrow}

\medskip
\bf{プロジェクトファイルの整合性 --- Windows (Visual Studio)の場合}
\label{subsec:Problems:ProjectFileIntegration}
\begin{narrow}[20pt]
	ソースファイルの内容を修正しただけならば
	プロジェクトファイルが変更されることはありません。
	しかし、ソースファイルの追加や削除を行なったならば
	プロジェクトファイルにも変更が及びます
	(Visual Studio上でソースの追加・削除を行なってセーブを行なった場合、
	もしくは\App{1}での変更後に再\cmake を行なった場合)。

	\medskip
	プロジェクトファイルもオブジェクトファイルと同様に
	ビルドツリー内に生成されますから、
	\App{1}で実施した変更が
	異なるビルドツリーをもつ\App{2}に反映されることはありません。
	しかも\App{2}で再ビルドしたとしても\App{1}での変更が反映されることはありません。
	\App{2}のプロジェクトファイルは\App{1}のものとは異なるファイルですから
	\App{2}は依然として古い状態を残したままなのです。

	\medskip
	これを解消するには\App{2}で再度\cmake を実行する必要がありますが、
	問題は\KQuote{\bf{いつ再\cmake が必要なのかが分からない}}ということです。
\end{narrow}

% end: 2.3.3.Problems.tex
