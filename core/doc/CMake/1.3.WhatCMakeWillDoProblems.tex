% 1.3.WhatCMakeWillDoProblems.tex
%	Last update: 2019/07/05 F.Kanehori
\newpage
\subsection{CMakeを使用した場合の問題点}
\label{subsec:WhatCMakeWillDoProblems}

前節の図2に示したアプリケーション(App1)の他にアプリケーション(App2)があったとして、
その両方を同時に開いて作業を行なう場合を考えます
(App2もApp1同様Springhead Libraryのプロジェクトを利用しているものとします)。

\medskip
ソースファイルについては、どちらもSpringhead Libraryのソースツリーの
(*1), (*2)などを指すようにしてありますから、
どちらで実施したソースファイルの変更も直ちに他方に反映されることになります
(同じファイルを参照しているのですから当然です)。

\medskip
オブジェクトファイルはどうでしょうか。
残念なことにApp1とApp2のビルドツリーは異なるものですから、
App1でソースを変更してビルドしたとしても
そのビルド結果がそのままApp2に反映されることはありません
(これらは異なるファイルです)。
しかしApp2で再ビルドを行なえば、
その時点でApp1の変更がApp2に反映されることになります。

\medskip
では、プロジェクトファイルはどうでしょうか。
ソースファイルの変更を行なうだけならば、
プロジェクトファイルが変更されることはありません。
しかし、ソースファイルの追加や削除を行なったならば
プロジェクトファイルにも変更が及びます
(Visual Studio上でソースの追加/削除を行なってセーブを行なった場合、
再度\cmake を実行した場合など)。

プロジェクトファイルもオブジェクトファイルと同様にビルドツリー内に生成されますから、
App1で実施した変更がApp2に反映されることはありません。
しかもApp2で再\cmake したとしてもApp1の変更が反映されることはありません。
App2のプロジェクトファイルはApp1のものとは異なるファイルですから
App2は依然として古い状態を残したままなのです。

\medskip
オブジェクトファイルの件は、
無駄なコンパイルが発生するという点に目をつぶれば許容できなくはない範疇かも知れません
(Visual Studioでは実行しようとすればビルドが走ります。
unixの場合は実行前にかならず\tt{make}をしないといけないですが)。
これは``\bf{ビルドの最適化}''の問題です。

しかし、プロジェクトファイルの件は許容できる範囲を超えています。
例えばApp1で今まであったファイルを削除する変更を行なったとします
(ソースツリーが変更される)。
するとApp2でビルドをすると``ファイルがない''というエラーが発生して
ビルドに失敗することになります。
このような場合には、App2で再度\cmake を実行してプロジェクトファイルを
作り直す(configureし直す)必要が生じるのです。
これは``\bf{ビルド構成の整合性}''の問題です。

% end: 1.3.WhatCMakeWillDoProblems.tex
