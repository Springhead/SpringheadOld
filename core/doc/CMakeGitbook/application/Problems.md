## 問題点

前節 [CMakeを使用した場合](/application/CmakeMethod.md) で示したような
アプリケーション *App1* の他に *App2* があったとして、
その両方を同時に開いて作業を行なう場合を考えます。
ここでは *App1* と *App2* とが共通して参照する Springhead Library の
プロジェクトについてのみ考えます。

** ソースファイルの整合性 **

ソースファイルの整合性には問題点はありません。
*App1* と *App2* のどちらも Springhead Library のソースツリーを指すように
してありますから、
どちらで実施したソースファイルの変更も直ちに他方に反映されることになります
 (同じファイルを参照していますから当然です)。

ソースファイルの追加や削除を実施したとしても、
ソースファイルの整合性自体が崩れる訳ではありません。
ただし、この場合には **プロジェクトファイルの整合性** (後述) の問題が発生します。

<a id="BuildOptimality"></a>
** ビルドの最適性 (無駄なコンパイル) **

*App1* と *App2* のビルドツリーは異なるものですから、
*App1* でソースを変更してビルドしたとしてもそのビルド結果 (オブジェクトファイル) が
そのまま *App2* から見える訳ではありません。

*App2* でこの変更を反映させようとすれば *App2* での再ビルドが必要ですが、
再ビルドを行なった時点で初めて変更されたソースファイルが再コンパイルされ、
オブジェクトファイルの整合性がとれることになります。
従来はオブジェクトファイル自体が共有されていましたから、
このような無駄なコンパイルは発生しませんでした。

** プロジェクトファイルの整合性 (Visual Studio の場合) **

ソースファイルの内容を修正しただけならば
プロジェクトファイルが変更されることはありません。
しかし、ソースファイルの追加や削除を行なったならば
プロジェクトファイルにも変更が及びます
 (Visual Studio 上でソースの追加・削除を行なってセーブを行なった場合、
もしくは *App1* での変更後に再度 cmake を行なった場合)。

プロジェクトファイルもオブジェクトファイルと同様にビルドツリー内に生成されますから、
*App1* で実施した変更が、
異なるビルドツリーをもつ *App2* に反映されることはありません。
しかも *App2* で再ビルドしたとしても *App1* での変更が反映されることはありません。
*App2* のプロジェクトファイルは *App1* のものとは異なるファイルですから
 *App2* は依然として古い状態を残したままなのです。

これを解消するには *App2* で再度 cmake を実行すれば良いのですが、
問題は **“いつ再 cmake が必要なのかが分からない”** ということです。

